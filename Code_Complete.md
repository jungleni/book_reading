# 第1部分 打好基础
## 1 欢迎进入软件构件的世界
### 要点
* **软件构建是软件开发的核心活动**；构建活动是每个项目中唯一一项必不可少的工作。
* 软件构建的主要活动包括：详细设计、编码、调试、集成、开发者测试（包括单元测试和集成测试）。
* 构建也常被称作“编码”和“编程”
* 构建活动的质量对软件的质量有着实质性的影响。
* 你对“**如何进行构建**”的理解程度，决定了你这名程序员的优秀程度。

## 2 用隐喻来更充分地理解软件开发
### 要点
* 隐喻是启示而不是算法，因此它们往往有一点随意。
* 隐喻把软件开发过程与其他你熟悉的活动联系在一起，帮助你更好地理解。
* 有些隐喻比其他一些隐喻更贴切。
* 通过把软件的构建过程比作是房屋的建设过程，我们可以发现，**仔细的准备是必要的**，而大型项目和小型项目之间也是有差异的。
* 通过把软件开发中的实践比作是智慧工作箱中的工具，我们又发现，每位程序员都有许多工具，但并不存在任何一个能适用于所有工作的工具，因地制宜地选择正确工具是成为有效编程的程序员的关键。
* 不同的隐喻彼此并不排斥，应当使用对你最有益处的某种隐喻组合。

## 3 三思而后行：前期准备
### 要点
* 构建活动的准备工作的根本目标在于**降低风险**。要确认你的准备工作是在降低风险，而非增加风险。
* 如果你想开发高质量的软件，软件开发过程必须**由始至终关注质量**。在项目初期关注质量，对产品质量的正面影响比在项目末期关注质量的影响要大。
* 程序员的一部分工作是教育老板和合作者，告诉他们软件开发过程，包括在开始编程之前进行充分准备的重要性。
* 你所从事的软件项目的类型对构建活动的前期准备有重大影响——许多项目应该是高度迭代式的，某些应该是序列式的。
* 如果没有**明确的问题定义**，那么你可能会在构建期间解决错误的问题。
* 如果没有做完**良好的需求分析**工作，你可能没能察觉待解决问题的重要细节。如果需求变更发送在构建之后的阶段，其代价是“在项目早期更改需求”的20～100倍。因此在开始编程之前，你要确认“需求”已经到位了。
* 如果没有做完**良好的架构设计**，你可能会在构建期间用错误的方法解决正确的问题。架构变更的代价随着“为错误的架构编写的代码数量”增加而增加，因此，也要确认“架构”已经到位了。
* 理解项目的前期准备所采用的方法，并相应地选择构建方法。

## 4 关键的“构建”决策
### 要点
* 每种编程语言都有其优点和弱点。要知道你使用的语言的明确优点和弱点。
* 在开始编程之前，做好一些约定。“改变代码使之符合这些约定”是近乎不可能的。
* “构建的实践方法”的种类比任何单个项目能用到的要多。有意识地选择最适合你的项目的实践方法。
* 问问你自己，你采用的编程实践是对你所用的编程语言的正确响应，还是受它的控制？请记得“**深入一种语言去编程**”，不要仅“在一种语言上编程”。
* 你在技术浪潮中的位置决定了哪种方法是有效的——甚至是可能用到的。确定你在技术浪潮中的位置，并相应调整计划和预期目标。

# 第2部分 创建高质量的代码
## 5 软件构建中的设计
### 要点
* 软件的首要技术使命就是**管理复杂度**。以简单性作为努力目标的设计方案对此最有帮助。
* 简单性可以通过两种方式来获取：一是减少在同一时间所关注的本质性复杂度的量，二是避免生成不必要的偶然的复杂度。
* 设计是一种启发式的过程。固执于某一种单一方法会损害创新能力，从而损害你的程序。
* 好的设计都是迭代的。你尝试设计的可能性越多，你的最终设计方案就会变得越好。
* 信息隐藏是个非常有价值的概念。通过询问“我应该隐藏些什么？”能够解决很多困难的设计问题。

### 核对表：软件构造中的设计
#### 设计实践
* 你已经做过多次迭代，并且从众多尝试结果中选择最佳的一种，而不是简单选择第一次尝试的结果吗？
* 你尝试用多种方案来分解系统，以确定最佳方案吗？
* 你同时用自下而上和自上而下的方法来解决设计问题吗？
* 为了解决某些特定的问题，你对系统中的风险部分或者不熟悉的部分创建过原型、写出数量最少的可抛弃的代码吗？
* 你的设计方案被他人检查了吗（无论正式与否）？
* 你一直在展开设计，直到实施细节跃然纸上了吗？
* 你用某种适当的技术——比如说wiki、电子邮件、挂图、数码照片、UML、CRC卡片或者在代码写注释——来保留设计成果吗？

#### 设计目标
* 你的设计是否充分地处理了由系统架构层定义出并且推迟确定的事项吗？
* 你的设计被划分层次了吗？
* 你对把这一程序分解为子程序、包和类的方法感到满意吗？
* 你把对这个类分解成子程序的方式感到满意吗？
* 类与类之间的交互关系是否已经设计为最小化了？
* 类和子程序是否被设计为能够在其他的系统中重用？
* 程序是不是易于维护？
* 设计是否精简？设计出来的每一部分都绝对必要吗？
* 设计中是否采用了标准的技术？是否避免使用怪异且难以理解的元素？
* 整体而言，你的设计是否有助于最小化偶然性的和本质性的复杂度吗？ 


## 6 可以工作的类
### 要点
* 类的接口应**提供一致的抽象**。很多问题都是由于违背该原则而引起的。
* 类的**接口应隐藏一些信息**——如某个系统接口、某项设计决策、或一些实现细节。
* **包含往往比继承更为可取**——除非你要对“是一个/is a”的关系建模。
* 继承是一种有用的工具，但它往往会增加复杂度，这有违于**软件的首要技术使命——管理复杂度**。
* 类是管理复杂度的首选工具。要在设计类时给予足够的关注，才能实现这一目标。

## 7 高质量的子程序
### 要点
* 创建子程序最主要的目的是**提高程序的可管理性**，当然也有其他一些好的理由。其中，节省代码空间只是一个次要原因：提高可读性、可靠性和可修改性等原因都更重要一些。
* 有时候，把一些简单的操作写成独立的子程序也非常有价值。
* 子程序可以按照其内聚性分成很多类，而你应该让大多数子程序具有**功能上的内聚性**，这时最佳的一种内聚性。
* 子程序的名字是它的质量的指示器。如果名字糟糕但恰如其分，那就说明这个子程序设计得很差劲。如果名字糟糕而且又不准确，那么它就反映不出程序是干什么的。不管怎样，糟糕的名字都意味着程序需要修改。
* 只有在某个子程序的主要目的是返回由其名字所描述的特定结果时，才应该使用函数。
* 细心的程序员会非常谨慎地使用宏，而且只在万不得已时才使用。

## 8 防御式编程
### 要点
* 最终产品代码中对错误的处理方式要比“垃圾进，垃圾出”复杂得多。
* 防御式编程技术可以**让错误更容易发现、更容易修改**，并减少错误对产品代码的破坏。
* 断言可以帮助人们尽早发现错误，尤其是在大型系统和高可靠性的系统中，以及快速变化的代码中。
* 关于**如何处理错误输入**的决策是一项关键的错误处理决策，也是一项关键的高层设计决策。
* 异常提供了一种与代码正常流程角度不同的错误处理手段。如果留心使用异常，它可以成为程序员们知识工具箱中的一项有益补充，同时也应该在异常和其他错误处理手段之间进行权衡比较。
* 针对产品代码的限制并不适用于开发中的软件。你可以利用这一优势在开发中添加有助于**更快地排查错误的代码**。

## 9 伪代码编程过程
### 要点
* 创建类和子程序通常都是一个**迭代的过程**。在创建子程序的过程中获得的认识常常会反过来影响类的设计。
* 编写好的伪代码需要使用易懂的英语，要避免使用特定编程语言中才有的特性，同时要在意图的层面上写伪代码（即描述该做什么，而不是要怎么做）。
* 伪代码编程过程是一个行之有效的做详细设计的工具，它同时让编码工作更容易。伪代码会直接转化为注释，从而确保了注释的准确度和实用性。
* 不要只停留在你所想到的第一个设计方案上。反复使用伪代码做出多种方案，然后选出其中最佳的一种方案再开始编码。
* 每一步完成后都要检查你的工作成果，还要鼓励其他人帮你来检查。这样你就会在投入精力最少的时候，用最低的成本发现错误。

### 核对表：伪代码编程过程
* 是否检查过已满足所有的先决条件？
* 定义好这个类要解决的问题了吗？
* 高层次的设计是否足够清晰？能给这个类和其中的每一个子程序起一个好的名字吗？
* 考虑过该如何测试这个类及其中每一个子程序了吗？
* 关于效率的问题，你主要从稳定的接口和可读的实现这两个角度考虑吗？还是主要从满足资源和速度的预期目标的角度考虑过呢？
* 在标准函数库或其他代码库中寻找过可用的子程序或者组件了吗？
* 在参考书籍中查找过有用的算法了吗？
* 是否用详尽的伪代码设计好每一个子程序？
* 你在脑海里检查过伪代码吗？这些伪代码容易理解吗？
* 关注过那些可能会让你重返设计的警告信息了吗？
* 是否把伪代码正确地翻译成代码了？
* 你反复使用伪代码编程过程了吗？有没有根据需要把一些子程序拆分成更小的子程序？
* 在做出假定（assumptions）的时候有没有对它们加以说明？
* 已经删除掉那些冗余的注释了吗？
* 你是否采取了几次迭代中最好的结果？还是在第一次迭代之后就停止了？
* 你完全理解你的代码了吗？这些代码是否容易理解？

# 第3部分 变量
## 10 使用变量的一般事项
### 要点
* 数据初始化过程很容易出错，所以请用本章描述的初始化方法来避免由于非预期的初始值而造成的错误。
* 最小化每个变量的作用域。把同一变量的引用点集中在一起。把变量限定在子程序或类的范围之内。避免使用全局数据。
* 把使用相同变量的语句尽可能集中在一起。
* 早期绑定会减低灵活度，但有助于减小复杂度。晚期绑定可以增加灵活性，同时增加复杂度。
* 把每个变量用于唯一的用途。

## 11 变量名的力量
### 要点
* 好的变量名是提高程序可读性的一项关键要素。对特殊种类的变量，比如循环下标和状态变量，需要加以特殊的考虑。
* 名字要尽可能地具体。那些太模糊或者太通用以致于能够用于多种目的的名字通常都是很不好的。
* 命名规则应该能够区分局部数据、类数据和全局数据。它们还应当可以区分类型名、具名常量、枚举类型名字和变量名。
* 无论做哪种类型项目，你都应该采用某种变量命名规则。你所采用的规则的种类取决于你的程序的规模，以及项目成员的人数。
* 现代编程语言很少需要用到缩写。如果你真的要使用缩写，请使用项目缩写词典或者标准前缀来帮助理解缩写。
* 代码阅读的次数远远多于编写的次数。确保你所取的名字更侧重于阅读方便而不是编写方便。

## 12 基本数据类型
### 要点
* 使用特定的数据类型就意味着要记住适用于各个类型的很多独立的原则。用本章的核对表来确认你已经对常见问题做了考虑。
* 如果你的语言支持，创建自定义类型会使得你的程序更容易修改，并更具有自描述性。
* 当你用typedef或者其等价方式创建了一个简单类型的时候，考虑是否更应该创建一个新的类。

## 13 不常见的数据类型
### 要点
* 结构体可以使得程序更简单、更容易理解，以及更容易维护。
* 每当你打算使用结构体的时候，考虑采用类是不是会工作得更好。
* 指针很容易出错。用访问器子程序或类以及防御式编程实践来保护自己的代码。
* 避免使用全局变量，不只是因为它们很危险，还是因为你可以用其他更好的方法来取代它们。
* 如果你不得不使用全局变量，那么就通过访问器子程序来使用它。访问器子程序能为你带来全局变量所能带来的一切优点，还有一些额外好处。

# 第4部分 语句
## 14 组织直线型代码
### 要点
* 组织直线型代码的最主要原则是按照依赖关系进行排列。
* 可以用好的子程序名、参数列表、注释，以及——如果代码足够重要——内务管理变量来让依赖关系变得更明显。
* 如果代码之间没有顺序依赖关系，那就设法使相关的语句尽可能地接近。

## 15 使用条件语句
### 要点
* 对于简单的```if-else```语句，请注意```if```子句和```else```子句的顺序，特别是用它来处理大量错误的时候。要确认正常的情况是清晰的。
* 对于```if-then-else```语句串和```case```语句，选择一种最有利于阅读的排序。
* 为了捕捉错误，可以使用```case```语句中的```default```子句，或者使用```if-then-else```语句串中的最后那个```else```子句。
* 各种控制结构并不是生来平等的。请为代码的每个部分选用最合适的控制结构。


## 16 控制循环
### 要点
* 循环很复杂。保持循环简单有助于别人阅读你的代码。
* 保持循环简单的技巧包括：避免使用怪异的循环、减少嵌套层次、让入口和出口一目了然、把内务操作代码放在一处。
* 循环下标很容易被滥用。因此命名要准确，并且要把它们各自仅用于一个用途。
* 仔细地考虑循环，确认它在每一种情况下都运行正常，并且在所有可能的条件下都能退出。

## 17 不常见的控制结构
### 要点 
* 多个```return```可以增强子程序的可读性和可维护性，同时可以避免产生很深的嵌套逻辑。但是使用它的时候要多加小心。
* 递归能够很优雅地解决一小部分问题。对它的使用也要倍加小心。
* 在少数情况下，```goto```是编写可读性和可维护代码的最佳方法。但这种情况非常罕见。除非万不得已，不要使用```goto```。

## 18 表驱动法
### 要点
* 表提供了一种复杂的逻辑和继承结构的替换方案。如果你发现自己对某个应用程序的逻辑或者继承树关系感到困惑，那么问问自己它是否可以通过一个查询表加以简化。
* 使用表的一项关键决策是决定如何去访问表。你可以采取直接访问、索引访问或者阶梯访问。
* 使用表的另一项关键决策是决定应该把什么内容放入表中。

## 19 一般控制问题
### 要点
* 使布尔表达式简单可读，将非常有助于提高你的代码的质量。
* 深层次的嵌套使得子程序变得难以理解。所幸的是，你可以相对容易地避免这么做。
* 结构化编程是一种简单并且仍然适用的思想：你可以通过把顺序、选择和循环三者组合起来而开发出任何程序。
* 将复杂度降低到最低水平是编写高质量代码的关键。

# 第5部分 代码改善
## 20 软件质量概述
### 要点
* 开发高质量代码最终并没有要求你付出更多，只是你需要对资源进行重新分配，以低廉的成本来防止缺陷出现，从而避免代价高昂的修正工作。
* 并非所有的质量保证目标都可以全部实现。明确哪些目标是你希望达到的，并就这些目标和团队成员进行沟通。
* 没有任何一种错误检测方法能够解决全部问题，测试本身并不是排除错误的最有效方法。成功的质量保证计划应该使用多种不同的技术来检查各种不同类型的错误。
* 在构建期间应当使用一些有效的质量保证技术，但在这之前，一些具有同样强大功能的质量保证技术也是必不可少的。错误发现越早，它与其余代码的纠缠就越少，由此造成的损失也越少。
* 软件领域的质量保证是面向过程的。软件开发与制造业不一样，在这里并不存在会影响最终产品的重复的阶段，因此，最终产品的质量受到开发软件所用的过程的控制。

## 21 协同构建
### 要点
* 协同开发实践往往能比测试发现更多的缺陷，并且更有效率。
* 协同开发实践所发现错误的类型通常跟测试所发现的不同，这意味着你需要同时使用详查和测试来保证你软件的质量。
* 正式检查通过运用核对表、准备工作、明确定义的角色以及对方法的持续改善，将缺陷侦测的效率提升至最高。它往往能比走查发现更多的缺陷。
* 通常，结对编程拥有和详查相同的成本，并能产生质量相当的代码。当需要缩短开发周期的时候，结对编程就非常有价值。相对于单独工作来说，有些开发人员更喜欢结对工作。
* 正式检查可以应用在除代码之外的许多工作成果上，例如需求、设计以及测试用例等。
* 走查和代码阅读是详查的替代方案。代码阅读更富有弹性，能有效地利用每个人的时间。

## 22 开发者测试
### 要点
* 开发人员测试是完整测试策略的一个关键部分。独立测试也很重要，但这一主题超出了本书的范围。
* 同编码之后编写测试用例相比较，编码开始之前编写测试用例，工作量和花费的时间差不多，但是后者可以缩短缺陷-侦测-调试-修正这一周期。
* 即使考虑了各种可用的测试手段，测试仍然只是良好软件质量计划的一部分。高质量的开发方法至少和测试一样重要，这包括尽可能减少需求和设计阶段的缺陷。在检测错误方面，协同开发的成效至少与测试相当。这些方法所检测错误的类型也各不相同。
* 你可以根据各种不同的思路来产生很多测试用例，这些思路包括基础测试、数据流分析、边界分析、错误数据类型以及正确数据类型等。你还可以通过猜测错误的方式得到更多的测试用例。
* 错误往往集中在少数几个容易出错的类和子程序上。找出这部分代码，重新设计和编写它们。
* 测试数据本身出错的密度往往比被测代码还要高。查找这种错误完全是浪费时间，又不能对代码有所改善，因此测试数据里面的错误更加让人烦恼。要像写代码一样小心地开发测试用例，这样才能避免产生这种问题。

## 23 调试

## 24 重构
## 25 代码调整策略
## 26 代码调整技术